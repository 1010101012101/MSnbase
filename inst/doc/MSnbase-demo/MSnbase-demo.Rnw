%\VignetteIndexEntry{Base Functions and Classes for MS-based Proteomics}
%\VignetteKeywords{Mass Spectrometry, MS, MSMS, Proteomics, Infrastructure, Bioinformatics, quantitative }
%\VignettePackage{MSnbase-demo}
\documentclass{article}
\usepackage{tikz}
\usepackage[nogin]{Sweave}
\usepackage{hyperref}
\usepackage[authoryear,round]{natbib}

\SweaveOpts{echo=T,eval=T,fig=F,results=verbatim,cache=F,tikz=T,external=F,prefix.string=sweave-cache/figs/fig}

\newcommand{\R}{\texttt{R} }
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\email}[1]{\href{mailto:#1}{\normalfont\texttt{#1}}}
%% colors
\definecolor{Red}{rgb}{0.7,0,0}
\definecolor{Blue}{rgb}{0,0,0.8}

\hypersetup{%
  hyperindex = {true},
  colorlinks = {true},
  linktocpage = {true},
  plainpages = {false},
  linkcolor = {Blue},
  citecolor = {Blue},
  urlcolor = {Red},
  pdfstartview = {Fit},
  pdfpagemode = {UseOutlines},
  pdfview = {XYZ null null null}
}

\input{Author.tex}

\begin{document}

\title{\Rpackage{MSnbase}: labelled MS2 data pre-processing, visualisation and quantification.}

\maketitle

%% Abstract and keywords %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vskip 0.3in minus 0.1in
\hrule
\begin{abstract}
  This vignette describes the functionality implemented in the \Rpackage{MSnbase} package. 
  \Rpackage{MSnbase} aims at (1) facilitating the upload, processing, visualisation and 
  quantification of mass spectrometry data into the \R environment \citep{Rstat} by providing 
  specific data classes and methods and (2) enabling the utilisation of throughput-high data 
  analysis pipelines provided by the Bioconductor \citep{Gentleman2004} project. 
\end{abstract}
\textit{Keywords}: Mass Spectrometry (MS), proteomics, infrastructure, bioinformatics, quantitative.
\vskip 0.1in minus 0.05in
\hrule
\vskip 0.2in minus 0.1in
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%% <<setup,cache=FALSE>>=
%%  setCacheDir("sweave-cache/values")
%% @ 

<<environment,cache=FALSE,echo=FALSE>>=
library("MSnbase")
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{Foreword.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{sec:intro} 

\Rpackage{MSnbase} aims are providing a reproducible research framework to proteomics data analysis. 
It should allow researcher to easily mine mass spectrometry data, explore the data and its statistical properties 
and visually display these.

\Rpackage{MSnbase} also aims at being compatible with the infrastructure implemented in Bioconductor, 
in particular \Rpackage{Biobase}. As such, classes 
developed specifically for proteomics mass spectrometry data are based on the \Robject{eSet} 
and \Robject{Expression} classes. The main goal is to assure seamless compatibility with 
existing meta data structure, accessor methods and normalisation techniques. 

This vignette illustrates \Rpackage{MSnbase} utility using a dummy data sets provided with the package 
without describing the underlying data structures. More details can be found in the 
package, classes, method and function documentations. A description of the classes is provided 
in the \texttt{MSnbase-development} vignette.

\input{NoteAboutSpeedAndMemory.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Importing raw data}\label{sec:msnexp}

Raw data is contained in \Robject{MSnExp} objects, that stores all the spectra of an experiment, 
as defined by one or multiple raw data files. 

\Rpackage{MSnbase} imports raw MS data stored in \texttt{mzXML} 
format \citep{Pedrioli2004} with the function \Rfunction{readMzXMLData} function. 
More formats, notably \texttt{mzML} \citep{Martens2010}, will be added at a later stage. 
Either MS1 or MS2 spectra can be loaded at a time by setting the \texttt{msLevel} parameter accordingly.


<<MSnExp,cache=FALSE,echo=TRUE>>=
library("MSnbase")
filename <- dir(system.file(package="MSnbase",dir="extdata"),
                full.name=TRUE,pattern="mzXML$")
print(filename)
experiment <- readMzXMLData(filename, msLevel = 2, verbose=FALSE)
experiment
@

<<experiment-size,echo=FALSE,cache=FALSE>>=
sz <- sum(sapply(assayData(experiment),object.size)) + object.size(experiment)
sz <- round(sz/(1024^2),2)
@ 

As illustrated above, showing the experiment textually displays it's content: 
\begin{itemize}
  \item Information about the raw data, i.e. the spectra.
  \item Specific information about the experiment processing\footnote{%%
    this part will be automatically updated when the object is 
    modified with it's \textit{ad hoc} methods, as illustrated later} and package version.
    This slot can be accessed with the \Rfunction{processingData} method.
  \item Other meta data, including experimental phenotype, 
    file name(s) used to import the data, protocol data, 
    information about features (individual spectra here) and
    experiment data. Most of these are implemented as 
    in the \Robject{eSet} class and are described in more details in their 
    respective manual pages. See \texttt{?MSnExp}
    and references therein for additional background information. 
    
    The experiment meta data associated with an \Robject{MSnExp} experiment
    is of class \Robject{MIAPE}. It stores general information about the 
    experiment as well as MIAPE (Minimum Information About a Proteomics Experiment, 
    \citep{Taylor2007, Taylor2008}) information.
    This meta-data can be accessed with the \Rfunction{experimentData} method. 
    When available, a summary of MIAPE-MS data can be printed with the \Rfunction{msInfo} method.
    See \texttt{?MIAPE} for more details.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Spectra objects}\label{sec:spectra}

The raw data is composed of the \Sexpr{length(experiment)} MS spectra. 
The spectra are named individually 
(\Sexpr{paste(paste(head(featureNames(experiment)),collapse=", "),", ...",sep="")})
and stored in a \Robject{environment}. They can be accessed individually with 
\texttt{experiment[["X10"]]} or as a list with \texttt{spectra(experiment)}.
As we have loaded our experiment specifying \texttt{msLevel=2}, 
the spectra will all be of level 2 (or higher, if available). 

<<Spectrum,cache=FALSE,echo=TRUE>>=
sp <- experiment[["X43"]]
sp
@ 

Attributes of individual spectra or of all spectra of an experiment can be 
accessed with their respective methods: \Rfunction{precursorCharge} for the 
precursor charge, \Rfunction{rtime} for the retention time, \Rfunction{mz} 
for the MZ values, \Rfunction{intensity} for the inensities, \ldots see the 
\Robject{Spectrum}, \Robject{Spectrum1} and \Robject{Spectrum2} manuals for more details.

<<accessors,cache=FALSE,echo=TRUE>>=
peaksCount(sp)
head(peaksCount(experiment))
rtime(sp)
head(rtime(experiment))
@ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reporter ions}\label{sec:reporterions}

Reporter ions are defined with the \Robject{ReporterIons} class. 
Specific peaks of interest are defined by a MZ value, a with 
around the expected MZ and a name (and optionally a colour for plotting, 
see section \ref{sec:plotting}). \Robject{ReporterIons} instances 
are required to quantify reporter peaks in \Robject{MSnExp} 
experiments. Instances for the most commonly used isobaric tags like 
iTRAQ 4-plex and 8-plex and TMT tags are already defined in 
\Rpackage{MSnbase}. See \texttt{?ReporterIons} for details about how 
to generate new \Robject{ReporterIons} objects.

<<ReporterIons>>=
iTRAQ4
@ 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Plotting raw data}\label{sec:plotting}

Spectra can be plotted individually or as part of (subsetted) experiments 
with the \Robject{plot} method. Full spectra can be plotted 
(using \texttt{full=TRUE}), specific reporter ions of interest 
(by specifing with reporters with \texttt{reporters=iTRAQ4} for instance) 
or both (see figure \ref{fig:spectrum-plot}).

\begin{figure}[!ht]
<<spectrum-plot,fig=T,echo=T,tikz=T,external=F,width=5,height=5>>=
plot(sp,reporters=iTRAQ4,full=TRUE) 
@ 
\caption{Raw MS2 spectrum with details about reporter ions.}
\label{fig:spectrum-plot}
\end{figure}


It is also possible to plot all spectra of an experiment (figure \ref{fig:msnexp-plot}). 
Lets start by extracting all spectra that have the same precursor MZ value than \Robject{sp} 
into a separate experiment, using the \Rfunction{extractPrecSpectra} method. 
This method takes an \Robject{MSnExp} experiment and a precursor MZ value as parameters.

<<extractPrecSpec,echo=T,cache=F>>=
exp2 <- extractPrecSpectra(experiment,precursorMz(sp))
exp2
@ 

We see that \Sexpr{length(exp2)} spectra have the same MZ value. 
These can be visulaised together by plotting the 
\Robject{MSnExp} object, as illustrated on figure \ref{fig:msnexp-plot}.

\begin{figure}[!ht]
<<msnexp-plot,fig=T,echo=T,tikz=T,external=F,width=5,height=6>>=
plot(exp2,reporters=iTRAQ4,full=FALSE)
@ 
\caption{Experiment-wide raw MS2 spectra.}
\label{fig:msnexp-plot}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data processing}\label{sec:processing}

There are several methods implemented to perform basic data manipulation. 
Low intensity peaks can be set to 0 with the \Rfunction{removePeaks} method 
from spectra or whole experiments. The intensity threshold below which peaks are removed 
is defined by the \Robject{t} parameter. \Robject{t} can be specified directly 
as a numeric. The default value is the character \texttt{"min"}, that will remove 
all peaks equal to the lowest non null intensity in any spectrum. 
We observe the effect of the \Rfunction{removePeaks} method by comparing 
total ion count (i.e. the total intensity in a spectrum) with the \Rfunction{tic} method
before (object \Robject{sp}) and after (object \Robject{experiment}). 
Figure \ref{fig:spectrum-plot2} illustrated spectrum \texttt{X43} after low intensity 
peaks removal.

<<removePeaks,echo=TRUE,cache=FALSE>>=
experiment <- removePeaks(experiment,t=3,verbose=FALSE)
## total ion current
tic(sp)
tic(experiment[["X43"]])
@ 

\begin{figure}[!ht]
<<spectrum-plot2,fig=T,echo=T,tikz=T,external=F,width=5,height=5>>=
plot(experiment[["X43"]],reporters=iTRAQ4,full=TRUE) 
@ 
\caption{Same spectrum as on figure \ref{fig:spectrum-plot}, 
  after setting peaks <= 3 to 0.}
\label{fig:spectrum-plot2}
\end{figure}


Unlike the name might suggest, the \Rfunction{removePeaks} method does 
not actually remove peaks from the spectrum; they are set to 0. This 
can be checked using the \Rfunction{peaksCount} method, that returns 
the number of peaks (including 0 intensity peaks) in a spectrum.
To effectively remove 0 intensity 
peaks from spectra, and reduce the size of the data set, one can use 
the \Rfunction{clean} method. 
The effect of the \Rfunction{removePeaks} and \Rfunction{clean} methods 
are illustrated on figure \ref{fig:preproc} on page \pageref{fig:preproc}.

<<clean,echo=TRUE,cache=FALSE>>=
## number of peaks
peaksCount(sp)
peaksCount(experiment[["X43"]])
experiment <- clean(experiment,verbose=FALSE)
peaksCount(experiment[["X43"]])
@ 


<<preprosp,cache=FALSE,echo=FALSE>>=
int <- c(0,1,1,3,1,1,0,0,0,1,3,7,3,1,0)
mz <- c(113.9,114.0,114.05,114.1,114.15,114.2,114.25,
        114.3,114.35,114.4,114.42,114.48,114.5,114.55,114.6)
ppsp <- new("Spectrum2",intensity=int,mz=mz,centroided=FALSE)
p1 <- plot(ppsp,full=TRUE) + theme_gray(5) + 
  geom_point(size=3,alpha=I(1/3)) +
  geom_hline(yintercept=3,linetype=2) + 
  opts(title="Original spectrum") 
p2 <- plot(removePeaks(ppsp,t=3),full=TRUE) + 
  theme_gray(5) +
  geom_point(size=3,alpha=I(1/3)) + 
  geom_hline(yintercept=3,linetype=2) + 
  opts(title="Peaks < 3 removed") 
p3 <- plot(clean(removePeaks(ppsp,t=3)),full=TRUE) + 
  theme_gray(5) +
  geom_point(size=3,alpha=I(1/3)) + 
  geom_hline(yintercept=3,linetype=2) + 
  opts(title="Peaks < 3 removed and cleaned") 
@

\begin{figure}[p]
  \begin{center}
<<preproc-plot,fig=T,echo=F,tikz=T,external=F,width=3,height=6>>=
grid.newpage()
pushViewport(viewport(layout = grid.layout(3, 1)))
vplayout <- function(x, y)
  viewport(layout.pos.row = x, layout.pos.col = y)
print(p1, vp=vplayout(1,1))
print(p2, vp=vplayout(2,1))
print(p3, vp=vplayout(3,1))
@ 
\caption{This figure illustrated the effect or the \Rfunction{removePeaks} 
  and \Rfunction{clean} methods. The left-most spectrum displays two peaks, 
  of max height 3 and 7 respectively. The middle spectrum shows the result 
  of calling \Rfunction{removePeaks} with argument \Robject{t=3}, which sets 
  all data points of the first peak, whose maximum height is smaller or equal 
  to \Robject{t} to 0. The second peak is unaffected. Calling \Rfunction{clean} 
  after \Rfunction{removePeaks} effectly deletes successive 0 intensities from 
  the spectrum, as shown on the right plot. }
\label{fig:preproc}
  \end{center}
\end{figure}

Another useful manipulation method is \Rfunction{trimMz}, that takes as 
parameters and \Robject{MSnExp} (or a \Robject{Spectrum}) and a numeric 
\Robject{mzlim}. MZ values smaller then \texttt{min(mzlim)} 
or greater then \texttt{max(mzmax)} are discarded. This method is 
particularely useful when one wants to concentrate on a specific MZ range, 
as for reporter ions quantification, and generally results in substantial 
reduction of data size. Compare the size of the full trimmed experiment to 
the original \Sexpr{sz} Mb.
\label{trimMz-example}

<<trimMz,echo=TRUE,cache=FALSE>>=
range(mz(sp))
experiment <- trimMz(experiment,mzlim=c(112,120))
range(mz(experiment[["X43"]]))
experiment
@ 

As can be seen above, all processing performed on the experiment is recorded 
and displayed as integral part of the experiment object.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Section
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{From spectra to quantitative expression data}

\subsection{Reporter ions quantitation}\label{sec:quant}

Quantitation is performed on specific peaks in the spectra, that are specified 
with an \Robject{ReporterIon} object. A specific peak is defined by it's expected 
\Robject{mz} value and is expected to be found within \Robject{mz} $\pm$ \Robject{width}.  
If no data is found, \Robject{NA} is returned.

<<reporters,echo=TRUE,cache=FALSE>>=
mz(iTRAQ4)
width(iTRAQ4)
@ 

The \Rfunction{quantify} method takes the following paramters: 
an \Robject{MSnExp} experiment, 
a character describing the quantification \Robject{method}, 
the \Robject{reporters} to be quantified 
and a \Robject{strict} logical defining whether data points 
ranging outside of \Robject{mz} $\pm$ \Robject{width} should be considered 
for quantitation. 
Additionally, a progress bar can be dispaying when setting 
the \Robject{verbose} parameter to \Robject{TRUE}.
Three quantification methods are implemented, as illustrated 
on figure \ref{fig:quant-methods}: 
\Robject{trapezoidation} returns the area under the peak of interest, 
\Robject{max} returns the apex of the peak and 
\Robject{sum} returns the sum of all intensities of the peak. 
See \texttt{?quantify} for more details.

<<simplesp,cache=FALSE,echo=FALSE>>=
int <- c(0,1,1,3,1,1,0)
mz <- c(113.9,114.0,114.05,114.1,114.15,114.2,114.25)
ssp <- new("Spectrum2",intensity=int,mz=mz,centroided=FALSE)
p <- plot(ssp,full=TRUE)
p <- p + theme_gray(5)
@ 

\begin{figure}[p]
<<quantitation-plot,fig=T,echo=F,tikz=T,external=F,width=5,height=5>>=
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))
vplayout <- function(x, y)
  viewport(layout.pos.row = x, layout.pos.col = y)
print(p + opts(title="Quantitation using 'sum'") + geom_point(size=3,alpha=I(1/3),colour="red"), vp=vplayout(1,1))
print(p + opts(title="Quantitation using 'max'") + geom_point(aes(x=114.1,y=3),alpha=I(1/3),colour="red",size=3), vp=vplayout(1,2))
print(p + opts(title="Trapezoidation and strict=FALSE") + geom_polygon(alpha=I(1/5),fill="red"),vp=vplayout(2,1))
print(p + opts(title="Trapezoidation and strict=TRUE") + 
      geom_polygon(aes(x=c(114.05,114.05,114.1,114.15,114.15),y=c(0,1,3,1,0)),fill="red",alpha=I(1/5)),vp=vplayout(2,2))
@ 
\caption{The different quantitation methods are illustrated above. 
  Quantitation using \Robject{sum} sums all the data points in the peaks to 
  produce, for ths example, \Sexpr{quantify(sp,iTRAQ4[1],method="sum")[[1]]}, 
  whereas method \Robject{max} only uses the peak's maximum intensity, 
  \Sexpr{quantify(sp,iTRAQ4[1],method="max")[[1]]}. 
  \Robject{Trapezoidation} calculates the area under the peak taking 
  the full with into account (using \Robject{strict=FALSE} gives
  \Sexpr{round(quantify(ssp,iTRAQ4[1],method="trap",strict=FALSE)[[1]],3)}) 
  or only the width as defined by the reporter 
  (using \Robject{strict=TRUE} gives
  \Sexpr{round(quantify(ssp,iTRAQ4[1],method="trap",strict=TRUE)[[1]],3)}). }
\label{fig:quant-methods}
\end{figure}

\bigskip

The \Rfunction{quantify} method returns \Robject{MSnSet} objects, that 
extend the well-known \Robject{eSet} class defined in the 
\Rpackage{Biobase} package. \Robject{MSnSet} instances are very similar 
to \Robject{ExpressionSet} objects, except for the experiment meta-data 
that captures MIAPE specific information.
The assay data is a matrix of dimensions 
$n \times m$, where $m$ is the  number of features/spectra 
originally in the \Robject{MSnExp} used as parameter in 
\Robject{quantify} and $m$ is the number of reporter ions, that 
can be accessed with the \Rfunction{exprs} method.
The meta data is directly inherited from the \Robject{MSnExp} instance.

<<quantify,echo=TRUE,cache=FALSE,keep.source=T>>=
qnt <- quantify(experiment,
                method="trap",
                reporters=iTRAQ4,
                strict=FALSE,
                verbose=FALSE)
qnt
head(exprs(qnt))
@ 

\subsection{Normalisation}\label{sec:norm}

A \Robject{MSnSet} object is meant to be compatible with further downstream 
packages for data normalisation and statistical analysis. 
Below is an example of applying 
variance stabilization normalisation \citep{Huber2002} 
to the iTRAQ reporter intensities \citep{Karp2010}.

<<vsn,echo=TRUE,cache=FALSE>>=
library("vsn")
qnt.vsn <- vsn2(exprs(qnt))
@ 

Figure 3 of \cite{Karp2010} is reproduced with 
the dummy experiment and show on figure \ref{fig:cv-plot}.

<<cvdata,echo=FALSE,cache=FALSE>>=
sd1 <- apply(log2(exprs(qnt))+10,1,sd)
mn1 <- apply(log2(exprs(qnt))+10,1,mean)
cv1 <- sd1/mn1
sd2 <- apply(exprs(qnt.vsn)+10,1,sd)
mn2 <- apply(exprs(qnt.vsn)+10,1,mean)
cv2 <- sd2/mn2
library("zoo")
## rmed1 <- rollapply(cv1,7,function(x) median(x,na.rm=TRUE))
## rmed2 <- rollapply(cv2,7,function(x) median(x,na.rm=TRUE))
##
## Calling directly rollapply.zoo to make it zoo_1.6-4 compatible.
## The above requires zoo >= 1.7-0, which is as of 15 March 2011
## not yet available on CRAN (only on r-forge).
rmed1 <- zoo:::rollapply.zoo(cv1,7,function(x) median(x,na.rm=TRUE))
rmed2 <- zoo:::rollapply.zoo(cv2,7,function(x) median(x,na.rm=TRUE))
@ 

\begin{figure}[!ht]
<<cv-plot,fig=T,echo=F,tikz=T,external=F,width=5,height=5>>=
plot(order(mn1),cv1,col="steelblue",pch=19,
     ylab="CV",xlab="Rank mean")
points(order(mn2),cv2,col="red",pch=19)
grid()
lines(seq(1,70,by=(70/length(rmed1))),rmed1,col="steelblue",lwd=2)
lines(seq(1,70,by=(70/length(rmed2))),rmed2,col="red"      ,lwd=2)
## legend("topright",
##        legend=c("log2","vsn","running\nmedian"),
##        pch=c(19,19,NA),
##        col=c("steelblue","red","black"),
##        lwd=c(0,0,2),
##        bty="n",
##        cex=.7)
@ 
\caption{CV versus signal intensity comparison for log2 (blue) and vsn (red) transformed data. Lines indicate running CV medians.}
\label{fig:cv-plot}
\end{figure}

\subsection{Feature aggregation}

The above quantitation and normalisation has been performed on quantitative data 
obtained from individual spectra. However, the biological unit of interest is not 
the spectrum but the peptide or the protein. As such, it is important to be able to 
summarise features that belong to a same group, i.e. spectra from one peptide, 
peptides that originate from one protein, or directly combine all spectra that have 
been uniquely associated to one protein. 

\Rpackage{MSnbase} provides one function, \Rfunction{combineFeatures}, that allows 
to aggregate features stored in an \Robject{MSnSet} using build-in or user 
defined summary function and return a new \Robject{MSnSet} instance. 
The function has three main argument here described below. 
Additional details can be found in the function manual. 

<<makeGroups1,echo=FALSE,cache=FALSE>>=
gb <- as.factor(fData(qnt)$precursor.mz)
@ 

\Rfunction{combineFeatures}'s first argument, \Robject{object}, is an instance of class \Robject{MSnSet}, 
as has been created in the section \ref{sec:quant} for instance. 
The second argument, \Robject{groupBy}, is a \Robject{factor} than has as many elements as 
there are features in the \Robject{MSnSet} \Robject{object} argument. The features corresponding 
to the \Robject{groupBy} levels will be aggregated so that the resulting \Robject{MSnSet} output 
will have \Rfunction{length(levels(groupBy))} features. Here, we will combine individual 
MSMS spectra based on their precursor mass-to-charge ratio. This information has been saved 
in the \Robject{MSnSet}'s \Robject{featureData} slot during the quantitation (see section \ref{sec:quant}). 
As shown below, this will result in \Sexpr{length(table(gb))} new aggregated features.

<<makeGroups2,echo=TRUE,cache=FALSE>>=
names(fData(qnt))
head(fData(qnt)$precursor.mz)
gb <- as.factor(fData(qnt)$precursor.mz)
table(gb)
@ 

The third argument, \Robject{fun}, 
defined how to combine the features. Predefined functions are readily available and can be 
specified as strings 
(\Robject{fun="mean"}, \Robject{fun="median"}, \Robject{fun="sum"}, 
\Robject{fun="weigthed.mean"} or \Robject{fun="medianpolish"} to compute respectively the mean, 
media, sum, weighted mean or median polish of the features to be aggregated). 
Alternatively, is is possible to supply userdefined functions with 
\Robject{fun=function(x) \{ ... \}}. We will use the \Robject{median} here.

<<combineFeatures,echo=TRUE,cache=FALSE>>=
qnt2 <- combineFeatures(qnt,groupBy=gb,fun="median")
qnt2
@ 

Other intended ways to define aggregation groups is to import 
identification data into R and collate it to the \Robject{MSnSet} 
feature data, and subsequently use peptide sequences or protein assignments 
to combine features. 

\section{Session information}\label{sec:sessionInfo} 
<<label=sessioninfo,results=tex,echo=FALSE,cache=FALSE>>=
toLatex(sessionInfo())
@

\bibliographystyle{plainnat}
\bibliography{MSnbase}

\end{document}
