% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quantitation.R
\name{quantify-methods}
\alias{quantify-methods}
\alias{quantify}
\title{Quantifies raw MS data objects}
\arguments{
\item{object}{Raw mass spectrometry data to be quantified. Can be
a single \code{\link[=Spectrum]{Spectrum()}} or a complete experiment provided as
\code{\link[=MSnExp]{MSnExp()}} or \code{\link[=OnDiskMSnExp]{OnDiskMSnExp()}}.}

\item{method}{An instance of \code{QuantitationParam} defining the
quantitation method. For isobaric tagging, the method
quantifies peaks defined in \code{\link[=IsobaricTagging]{IsobaricTagging()}} object. For
MS2-based label-free quantitation, use a \code{\link[=SpectralCounting]{SpectralCounting()}}
quantitation parameter.\preformatted{See [QuantitationParam()] for additional details on how to
define quantiation parameters.
}}

\item{BPPARAM}{Support for parallel processing using the
\code{BiocParallel} infrastructure. When missing (default), the
default registered \code{BiocParallelParam} parameters are applied
using \code{bpparam()}. Alternatively, one can pass a valid
\code{BiocParallelParam} parameter instance: \code{SnowParam},
\code{MulticoreParam}, \code{DoparParam}, ... see the
\code{BiocParallel} package for details.}

\item{verbose}{\code{logical(1)} defining whether a progress bar should
be displayed when quantifying full experiments. Default is
\code{\link[=isMSnbaseVerbose]{isMSnbaseVerbose()}}.}

\item{...}{Further arguments passed to the quantitation functions.}
}
\value{
An object of class \code{\link[=MSnSet]{MSnSet()}} is returned containing the
quantified feature expression and all meta data inherited from
the mass spectrometry experiment data. When quantifying
individual spectra with isobaric tagging, a list of length 2
will be returned. The first element, named \code{peakQuant}, is a
\code{numeric} of length equal to the number of reportesr with
quantitation of the reporter peaks.\preformatted{The second element, named `curveStats`, is a `data.frame`
providing, for each reporter, its curve parameters: maximum
intensity *maxInt*, number of maxima *nMaxInt*, the number of
data points defined the curve *baseLength*, lower and upper MZ
values for the curve (*lowerMz* and *upperMz*), and reporter
reporter and precursor MZ values (when available).
}
}
\description{
These methods quantify individual spectra or full MS
experiments. Currently, MS2-level isobar tagging using iTRAQ
and TMT (or any arbitrary peaks of interest, see
\code{\link[=ReporterIons]{ReporterIons()}} and MS2-level label-free quantitation
(spectral counting, spectral index or spectral abundance
factor) are available, as described in
\code{\link[=QuantitationParam]{QuantitationParam()}}.
}
\details{
\code{\link[=ReporterIons]{ReporterIons()}} define specific MZ at which peaks are
expected and a window around that MZ value. A peak of interest
is searched for in that window.  Once the range of the curve
is found, quantification is performed.  If no data points are
found in the expected region, \code{NA} is returned for the
reporter peak MZ.\preformatted{For spectral counting, spectra that have not been identified
(the corresponding fields in the feature data are populated
with `NA` values) or that have not been uniquely assigned to a
protein (the `nprot` feature variable is greater that 1) are
removed prior to quantitation. The latter does not apply for
method `"count"` (see [QuantitationParam()]) but can be
applied manually with [removeMultipleAssignment()].
}
}
\examples{
## On-disk Raw data object
library("msdata")
f <- proteomics(full.names = TRUE, pattern = "MS3TMT11.mzML")
ms <- readMSData(f, mode = "onDisk")

## Isobaric quantitation
tmt11 <- IsobaricTagging(reporters = TMT11)
msnset <- quantify(ms, tmt11)
msnset

## All spectra are present in the quantified data, but only MS3
## spectra have been quantified.
head(exprs(msnset))
head(exprs(msnset)[msLevel(ms) == 3L, ])

## specifying a custom parallel framework
## bp <- MulticoreParam(2L) # on Linux/OSX
## bp <- SnowParam(2L)      # on Windows
## quantify(ms, tmt11, BPPARAM = bp)

## Quantifying a single spectrum (using the legacy interface only)
qty <- quantify(ms[[4]], method = tmt11@method, reporters = tmt11@reporters)
qty$curveStats
qty$peakQuant
## same as
exprs(msnset)[4, ]

## Label-free quantitation
## We need to first add identification data to the raw object
data(fdms3tmt11) ## from msdata
fData(ms) <- fdms3tmt11

## Spectral counting, setting the peptide sequence feature name to
## 'Sequence' (default is 'sequence'). 
sc <- SpectralCounting(pepseq = "Sequence")
## Quantitation for all spectra is returned
spc <- quantify(ms, sc)

## MS2 with a sequence are counted as 1
## MS2 without a sequence are counted as 0
## All other spectra as NA
head(exprs(spc))
head(fData(ms)[, c("msLevel", "Sequence")])

## Generate a peptide couting
## For example, this peptide was counted 3 times, in spectra 727,
## 733 and 737
hvl <- which(fData(spc)$Sequence == "HVLHVQLNRPNK")
exprs(spc)[hvl, , drop = FALSE]
combineFeatures(spc, fcol = "Sequence")

## Total ion count, returns values for all spectra
tc <- quantify(ms, SpectralCounting(method = "tic"))
head(exprs(tc))

## It is of course possible to focus only on MS levels of interest
## by either filtering the raw data object or the resulting MSnSet
## using the filterMsLevel method:
ms2 <- filterMsLevel(ms, 2L)
head(msLevel(ms2))
tc2 <- quantify(ms2, SpectralCounting(method = "tic"))
head(exprs(tc2))
head(exprs(filterMsLevel(tc, 2L)))
 
## TODO following ones
si <- quantify(msexp, method = "SIn")
processingData(si)
exprs(si)

saf <- quantify(msexp, method = "NSAF")
processingData(saf)
exprs(saf)
}
\seealso{
The legacy interface (i.e. that doesn't use
\code{QuantitationParams}) to \code{quantify}, in \link{quantify-legacy}.
}
\author{
Laurent Gatto and Sebastian Gibb
}
