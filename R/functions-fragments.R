#' calculate fragments from a peptide sequence
#' @param sequence character vector of length 1
#' @param type could be c("a", "b", "c", "x", "y", "z", "aIx", "bIy", "cIz")
#' @param z charge
#' @param modifications a named (amino acid one-letter-code; upper case) vector
#' of mass that should be added (default: Carbamidomethyl 57.02146 is added
#' to Cystein (C) and results in 160.030649).
#' @param neutralLoss list, currently water and ammonia loss are supported
#' @param verbose verbose output?
#' @noRd
.calculateFragments <- function(sequence, type = c("b", "y"), z = 1,
                                modifications = c(C = 57.02146),
                                neutralLoss = defaultNeutralLoss(),
                                verbose = isMSnbaseVerbose()) {
  ## TODO: this information should inform the user about a major API change
  ## and could be removed in MSnbase > 1.18
  if (packageVersion("MSnbase") < as.package_version("1.20.0")) {
    message("The mass listed in \"modifications\" is now added to the ",
            "amino acid/peptide.\n",
            "In MSnbase < 1.17.6 the mass was replaced. ",
            "Please see '?calculateFragments' for details.")
  }

  if (nchar(sequence) <= 1L) {
    stop("'sequence' has to have two or more residues.")
  }

  atypes <- c("a", "b", "c")
  ctypes <- c("x", "y", "z")
  itypes <- c("aIx", "bIy", "cIz")
  types <- c(atypes, ctypes, itypes)

  type <- match.arg(type, choices=types, several.ok=TRUE)

  ## constants
  mass <- get.atomic.mass()
  ## according to Table 1 of:
  ## Johnson, R. S., Martin, S. A., Biemann, K., Stults, J. T., and
  ## Watson, J. T. (1987).
  ## Novel fragmentation process of peptides by collision-induced
  ## decomposition in a tandem mass spectrometer: differentiation of leucine
  ## and isoleucine.
  ## Analytical Chemistry, 59(21), 2621-2625.
  ## http://dx.doi.org/10.1021/ac00148a019
  ##
  ## a proton (H+) is added later
  ## (after calculation of the different charge states)
  add <- c(a=-(mass["C"]+mass["O"]),            # + H - CO
           b=0,                                 # + H
           c=mass["N"]+3*mass["H"],             # + H + NH3
           x=mass["C"]+2*mass["O"],             # + CO + OH
           y=2*mass["H"]+mass["O"],             # + H2 + OH
           z=-(mass["N"]+mass["H"])+mass["O"],  # - NH2 + OH
           ### internal fragments
           aIx=mass["O"],                       # (- CO + CO) + OH
           bIy=2*mass["H"]+mass["O"],           # + H2 + OH
           cIz=mass["H"]+mass["O"])             # + NH3 - NH2 + OH
  names(add) <- types

  aa <- .get.amino.acids()
  aamass <- setNames(aa$ResidueMass, aa$AA)

  ## replace default mass by modifications
  if (length(modifications)) {
    aamass[names(modifications)] <- aamass[names(modifications)] + modifications
  }

  if (verbose) {
    if (length(modifications)) {
      mods <- paste0(names(modifications), "=", modifications, collapse=", ")
    } else {
      mods <- "None"
    }
    message("Modifications used: ", mods)
  }

  ## split peptide sequence into aa
  fragment.seq <- strsplit(sequence, "", fixed=TRUE)[[1L]]

  ## amino-terminus (for a, b, c)
  atype <- atypes %in% type
  atf <- .aterminus(fragment.seq, sequence, aamass, types=atypes[atype])

  ## carboxyl-terminus (for x, y, z)
  ctype <- ctypes %in% type
  ctf <- .cterminus(fragment.seq, sequence, aamass, types=ctypes[ctype])

  ## internal fragments
  itype <- itypes %in% type
  itf <- .internalFragments(sequence, aamass, types=itypes[itype])

  df <- data.frame(mz=c(atf$mz, ctf$mz, itf$mz),
                   pos=c(atf$pos, ctf$pos, itf$pos),
                   seq=c(atf$seq, ctf$seq, itf$seq),
                   type=c(atf$type, ctf$type, itf$type),
                   stringsAsFactors=FALSE)

  ## do actual calculation
  df$mz <- df$mz + add[df$type]

  ## create names
  df$ion <- paste0(df$type, df$pos)
  isInternal <- df$type %in% itypes
  df$ion[isInternal] <- paste0(df$type[isInternal], "[", df$pos[isInternal],
                               "-", df$pos[isInternal] +
                                 nchar(df$seq[isInternal]) - 1L, "]")
  ## devide by charge
  zn <- length(z)
  df <- df[rep(seq_len(nrow(df)), each=zn), ]
  df$mz <- df$mz / z
  df$z <- z

  ## add protons (H+)
  df$mz <- df$mz + mass["p"]

  df <- .neutralLoss(df, water=neutralLoss$water, ammonia=neutralLoss$ammonia)
  df <- .terminalModifications(df, modifications=modifications)
  rownames(df) <- NULL
  ## change column order
  df <- df[, c("mz", "ion", "type", "pos", "z", "seq")]
  df
}

#' adds neutral loss to data.frame generated by .calculateFragments
#' @param df data.frame generated by. calculateFragments
#' @return data.frame neutral loss rows added
#' @noRd
.neutralLoss <- function(df,
                         water=c("Cterm", "D", "E", "S", "T"),
                         ammonia=c("K", "N", "Q", "R")) {
  ## see "Low energy peptide fragmentation pathways" by Hugh-G. Patterton, Ph.D.
  ## http://cbio.ufs.ac.za/fgap/download/fragmentation_review.pdf
  ## see also discussion #47: https://github.com/lgatto/MSnbase/issues/47

  ## constants
  mass <- get.atomic.mass()

  widx <- double()
  aidx <- double()

  .removeNeutralLoss <- function(df, idx, mass, ion) {
    if (length(idx)) {
      loss <- df[idx, ]
      loss[, c("ion", "type")] <- paste0(c(loss$ion, loss$type), ion)
      loss$mz <- loss$mz - mass
      rbind(df, loss)
    } else {
      df
    }
  }

  if (length(water)) {
    ## N-term D/E, internal S/T
    rules <- c(D="^D.", E="^E.", S=".S.", T=".T.")
    rules <- rules[intersect(c("D", "E", "S", "T"), water)]

    if (length(rules)) {
      widx <- grep(paste0(rules, collapse="|"), df$seq)
    }

    ## C-term COOH (all x, y, z fragments)
    if ("Cterm" %in% water) {
      widx <- unique(c(widx, grep("[xyz]", df$type)))
    }
  }

  if (length(ammonia)) {
    ## N-term/internal K/N/Q, internal R
    rules <- c(K="^.*K.", N="^.*N.", Q="^.*Q.", R=".R.")
    rules <- rules[intersect(c("K", "N", "Q", "R"), ammonia)]

    if (length(rules)) {
      aidx <- grep(paste0(rules, collapse="|"), df$seq)
    }
  }

  if (length(widx)) {
    df <- .removeNeutralLoss(df, idx=widx, mass=mass["H"]+2*mass["O"], ion="_")
  }
  if (length(aidx)) {
    df <- .removeNeutralLoss(df, idx=aidx, mass=mass["N"]+3*mass["H"], ion="*")
  }
  df
}

#' adds nterm/cterm modifications to data.frame generated by .calculateFragments
#' should be used after .neutralLoss
#' @param df data.frame generated by. calculateFragments
#' @return modified data.frame
#' @noRd
.terminalModifications <- function(df, modifications) {

  if ("Nterm" %in% names(modifications)) {
    isABC <- grep("[abc]", df$type)

    if (length(isABC)) {
      df$mz[isABC] <- df$mz[isABC] + modifications["Nterm"] / df$z[isABC]
    }
  }

  if ("Cterm" %in% names(modifications)) {
    isXYZ <- grep("[xyz]", df$type)

    if (length(isXYZ)) {
      df$mz[isXYZ] <- df$mz[isXYZ] + modifications["Cterm"] / df$z[isXYZ]
    }
  }

  df
}

#' default neutral loss argument for calculateFragments
#' @param disableWaterLoss character, which loss should not calculated
#' @param disableAmmoniaLoss character, which loss should not calculated
#' @noRd
defaultNeutralLoss <- function(disableWaterLoss=NULL, disableAmmoniaLoss=NULL) {
  list(water=setdiff(c("Cterm", "D", "E", "S", "T"), disableWaterLoss),
       ammonia=setdiff(c("K", "N", "Q", "R"), disableAmmoniaLoss))
}

#' @param fragments one-letter sequence
#' @param sequence complete sequence
#' @param aamass aa residual mass
#' @param types
#' @noRd
.aterminus <- function(fragments, sequence, aamass, types) {
  fragments <- fragments[-length(fragments)]
  n <- length(fragments)
  times <- length(types)
  list(mz=rep.int(cumsum(aamass[fragments]), times),
       pos=rep.int(seq_len(n), times),
       seq=rep.int(substring(sequence, rep.int(1L, n), seq_len(n)), times),
       types=rep(types, each=n))
}

#' @param fragments one-letter sequence
#' @param sequence complete sequence
#' @param aamass aa residual mass
#' @param types
#' @noRd
.cterminus <- function(fragments, sequence, aamass, types) {
  fragments <- fragments[-1L]
  n <- length(fragments)
  times <- length(types)
  list(mz=rep.int(cumsum(aamass[rev(fragments)]), times),
       pos=rep.int(seq_len(n), times),
       seq=rep.int(rev(substring(sequence, seq_len(n) + 1L, rep.int(n + 1L, n))), times),
       types=rep(types, each=n))
}

#' internal fragments
#' @param fragments sequence
#' @param aamass aa residual mass
#' @param types
#' @param n length of sequence
#' @param l minimum fragment length (default: 2)
#' @noRd
.internalFragments <- function(fragments, aamass, types, n=nchar(fragments), times=length(types), l=2L) {
  if (n > 3L) {
    nr <- rev(seq_len(n - 3L))
    pos <- sequence(nr) + 1L
    end <- pos - 1L + rep.int(l:(n - 2L), nr)
    seq <- substring(fragments, pos, end)
    mz <- unlist(lapply(strsplit(seq, "", fixed=TRUE), function(y)sum(aamass[y])))
    list(mz=rep.int(mz, times),
         pos=rep.int(pos, times),
         seq=rep.int(seq, times),
         types=rep(types, each=length(mz)))
  } else {
    list(mz=double(), pos=double(), seq=character(), types=character())
  }
}
